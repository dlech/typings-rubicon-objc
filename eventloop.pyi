"""
This type stub file was generated by pyright.
"""

import sys
from asyncio import events, unix_events
from collections.abc import Callable
from ctypes import Structure, c_double, c_int, c_ulong
from typing import Any

from .runtime import objc_id

"""PEP 3156 event loop based on CoreFoundation."""
if sys.version_info < (3, 14): ...
else: ...
__all__ = ["EventLoopPolicy", "CocoaLifecycle", "RubiconEventLoop", "iOSLifecycle"]
libcf = ...
CFAllocatorRef = objc_id
kCFAllocatorDefault = ...
CFDataRef = objc_id
CFOptionFlags = c_ulong
CFStringRef = objc_id
CFTypeRef = objc_id
CFRunLoopRef = objc_id
CFRunLoopMode = CFStringRef
CFRunLoopSourceRef = objc_id
CFRunLoopTimerRef = objc_id
CFRunLoopTimerCallBack = ...
CFSocketRef = objc_id
CFSocketCallbackType = c_int
CFSocketCallback = ...
CFSocketNativeHandle = c_int
CFTimeInterval = c_double
CFAbsoluteTime = CFTimeInterval

class CFRunLoopTimerContext(Structure):
    _fields_ = ...

kCFRunLoopCommonModes = ...
kCFSocketNoCallBack = ...
kCFSocketReadCallBack = ...
kCFSocketAcceptCallBack = ...
kCFSocketDataCallBack = ...
kCFSocketConnectCallBack = ...
kCFSocketWriteCallBack = ...
kCFSocketAutomaticallyReenableReadCallBack = ...
kCFSocketAutomaticallyReenableWriteCallBack = ...
NSRunLoop = ...

class CFSocketContext(Structure):
    _fields_ = ...

class CFTimerHandle(events.TimerHandle):
    def __init__(self, *, loop, timeout, callback, args) -> None: ...
    def cancel(self) -> None:
        """Cancel the Timer handle."""
        ...

class CFSocketHandle(events.Handle):
    def __init__(self, *, loop, fd) -> None:
        """Register a file descriptor with the CFRunLoop, or modify its state so that
        it's listening for both notifications (read and write) rather than just one;
        used to implement add_reader and add_writer."""
        ...

    def enable_read(self, callback, args) -> None:
        """Add a callback for read activity on the socket."""
        ...

    def disable_read(self) -> None:
        """Remove the callback for read activity on the socket."""
        ...

    def enable_write(self, callback, args) -> None:
        """Add a callback for write activity on the socket."""
        ...

    def disable_write(self) -> None:
        """Remove the callback for write activity on the socket."""
        ...

    def cancel(self) -> None:
        """(Potentially) cancel the socket handle.

        A socket handle can have both reader and writer components; a call to cancel a
        socket handle will only be successful if *both* the reader and writer component
        have been disabled. If either is still active, cancel() will be a no-op.
        """
        ...

def context_callback(context, callback) -> Callable[..., None]: ...

class CFEventLoop(unix_events.SelectorEventLoop):
    def __init__(self, lifecycle=...) -> None: ...
    def __del__(self) -> None: ...
    def add_reader(self, fd, callback, *args) -> None:
        """Add a reader callback.

        Method is a direct call through to _add_reader to reflect an internal
        implementation detail added in Python3.5.
        """
        ...

    def remove_reader(self, fd) -> bool:
        """Remove a reader callback.

        Method is a direct call through to _remove_reader to reflect an internal
        implementation detail added in Python3.5.
        """
        ...

    def add_writer(self, fd, callback, *args) -> None:
        """Add a writer callback.

        Method is a direct call through to _add_writer to reflect an internal
        implementation detail added in Python3.5.
        """
        ...

    def remove_writer(self, fd) -> bool:
        """Remove a writer callback.

        Method is a direct call through to _remove_writer to reflect an internal
        implementation detail added in Python3.5.
        """
        ...

    def is_running(self) -> bool:
        """Returns True if the event loop is running."""
        ...

    def run(self) -> None:
        """Internal implementation of run using the CoreFoundation event loop."""
        ...

    def run_until_complete(self, future, **kw):
        """Run until the Future is done.

        If the argument is a coroutine, it is wrapped in a Task.

        /// warning | Warning

        It would be disastrous to call run_until_complete() with the same coroutine
        twice -- it would wrap it in two different Tasks and that can't be good.

        ///

        Return the Future's result, or raise its exception.
        """
        ...

    def run_forever(self, lifecycle=...) -> None:
        """Run until stop() is called."""
        ...

    def run_forever_cooperatively(self, lifecycle=...) -> None:
        """A non-blocking version of
        [`run_forever()`][rubicon.objc.eventloop.run_forever].

        This may seem like nonsense; however, an iOS app is not expected to invoke a
        blocking "main event loop" method. As a result, we need to be able to *start*
        Python event loop handling, but then return control to the main app to start the
        actual event loop.

        The implementation is effectively all the parts of a call to
        [`run_forever()`][rubicon.objc.eventloop.run_forever], but without any of the
        shutdown/cleanup logic.
        """
        ...

    def call_soon(self, callback, *args, context=...) -> CFTimerHandle:
        """Arrange for a callback to be called as soon as possible.

        This operates as a FIFO queue: callbacks are called in the
        order in which they are registered.  Each callback will be
        called exactly once.

        Any positional arguments after the callback will be passed to
        the callback when it is called.
        """
        ...

    call_soon_threadsafe = ...
    def call_later(self, delay, callback, *args, context=...) -> CFTimerHandle:
        """Arrange for a callback to be called at a given time.

        Return a Handle: an opaque object with a cancel() method that
        can be used to cancel the call.

        The delay can be an int or float, expressed in seconds.  It is
        always relative to the current time.

        Each callback will be called exactly once.  If two callbacks
        are scheduled for exactly the same time, it undefined which
        will be called first.

        Any positional arguments after the callback will be passed to
        the callback when it is called.
        """
        ...

    def call_at(self, when, callback, *args, context=...) -> CFTimerHandle:
        """Like call_later(), but uses an absolute time.

        Absolute time corresponds to the event loop's time() method.
        """
        ...

    def time(self) -> Any:
        """Return the time according to the event loop's clock.

        This is a float expressed in seconds since an epoch, but the epoch, precision,
        accuracy and drift are unspecified and may differ per event loop.
        """
        ...

    def stop(self) -> None:
        """Stop running the event loop.

        Every callback already scheduled will still run.  This simply informs
        run_forever to stop looping after a complete iteration.
        """
        ...

    def close(self) -> None:
        """Close the event loop.

        This clears the queues and shuts down the executor, but does not wait for the
        executor to finish.

        The event loop must not be running.
        """
        ...

if sys.version_info < (3, 16):
    from asyncio import AbstractEventLoopPolicy

    class EventLoopPolicy(AbstractEventLoopPolicy):
        """Rubicon event loop policy.

        In this policy, each thread has its own event loop. However, we only
        automatically create an event loop by default for the main thread; other
        threads by default have no event loop.

        **DEPRECATED** - Python 3.14 deprecated the concept of manually creating
        EventLoopPolicies. Create and use a `RubiconEventLoop` instance instead of
        installing an event loop policy and calling `asyncio.new_event_loop()`.
        """
        def __init__(self) -> None: ...
        def new_event_loop(self) -> CFEventLoop:
            """Create a new event loop and return it."""
            ...

        def get_default_loop(self) -> CFEventLoop:
            """Get the default event loop."""
            ...

if sys.version_info < (3, 14): ...
else:
    RubiconEventLoop = CFEventLoop

class CFLifecycle:
    """A lifecycle manager for raw CoreFoundation apps."""
    def __init__(self, cfrunloop) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class CocoaLifecycle:
    """A life cycle manager for Cocoa (`NSApplication`) apps."""
    def __init__(self, application) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class iOSLifecycle:
    """A life cycle manager for iOS (`UIApplication`) apps."""
    def start(self) -> None: ...
    def stop(self) -> None: ...
