"""
This type stub file was generated by pyright.
"""

import ctypes
import typing
from collections.abc import Callable, Iterator, Mapping, Sequence
from ctypes import Structure
from typing import Any, ParamSpec, Self, TypeVar, overload

from rubicon.objc.runtime import objc_id

__all__ = [
    "Block",
    "NSArray",
    "NSData",
    "NSDecimalNumber",
    "NSDictionary",
    "NSMutableArray",
    "NSMutableDictionary",
    "NSNumber",
    "NSObject",
    "NSObjectProtocol",
    "NSString",
    "ObjCBlock",
    "ObjCClass",
    "ObjCInstance",
    "ObjCMetaClass",
    "ObjCProtocol",
    "Protocol",
    "at",
    "for_objcclass",
    "get_type_for_objcclass_map",
    "ns_from_py",
    "objc_classmethod",
    "objc_const",
    "objc_ivar",
    "objc_method",
    "objc_property",
    "objc_rawmethod",
    "py_from_ns",
    "register_type_for_objcclass",
    "type_for_objcclass",
    "unregister_type_for_objcclass",
]
_keep_alive_objects = ...
_RETURNS_RETAINED_FAMILIES = ...

def get_method_family(method_name: str) -> str:
    """Returns the method family from the method name.

    See
    https://clang.llvm.org/docs/AutomaticReferenceCounting.html#method-families
    for documentation on method families and corresponding selector names.
    """
    ...

def method_name_to_tuple(name: str) -> tuple[str, tuple[str, ...]]:
    """
    Performs the following transformation:

    "methodWithArg0:withArg1:withArg2:" ->
    "methodWithArg0", ("", "withArg1", "withArg2")

    "methodWithArg0:" -> "methodWithArg0", ("", )

    "method" -> "method", ()

    The first element of the returned tuple is the "base name" of the method. The second
    element is a tuple with its argument names.
    """
    ...

def encoding_from_annotation(f, offset=...):  # -> list[Any]:
    ...

class ObjCMethod:
    """An unbound Objective-C method. This is Rubicon's high-level equivalent of
    :class:`~rubicon.objc.runtime.Method`.

    :class:`ObjCMethod` objects normally don't need to be used directly. To call
    a method on an Objective-C object, you should use the method call syntax
    supported by :class:`ObjCInstance`, or the
    :func:`~rubicon.objc.runtime.send_message` function.

    .. note::

        This is *not* the same class as the one used for *bound* Objective-C
        methods, as returned from :meth:`ObjCInstance.__getattr__`. Currently,
        Rubicon doesn't provide any documented way to get an unbound
        :class:`ObjCMethod` object for an instance method of an
        :class:`ObjCClass`.
    """
    def __init__(self, method) -> None:
        """The constructor takes a :class:`~rubicon.objc.runtime.Method` object, whose
        information is used to create an :class:`ObjCMethod`.

        This can be used to call or introspect a
        :class:`~rubicon.objc.runtime.Method` pointer received from the
        Objective-C runtime.
        """
        ...

    def __repr__(self):  # -> str:
        ...
    def __call__(
        self, receiver, *args, convert_args=..., convert_result=...
    ):  # -> c_void_p | Any | type[__class_ObjCClass] | ObjCInstance | None:
        """Call the method on an object with the given arguments.

        The passed arguments are automatically converted to the expected
        argument types as needed:

        * :class:`enum.Enum` objects are replaced by their
          :attr:`~enum.Enum.value` before further conversion
        * For parameters that expect a block, Python callables are converted to
          :class:`Block`\\s
        * For parameters that expect an Objective-C object, Python objects are
          converted using :func:`ns_from_py`
        * For parameters that expect a C structure, Python sequences are
          converted using
          :func:`~rubicon.objc.types.compound_value_for_sequence`.
        * Finally, :mod:`ctypes` applies its normal function argument
          conversions.

        The above argument conversions (except those performed by :mod:`ctypes`)
        can be disabled by setting the ``convert_args`` keyword argument to
        ``False``.

        If the method returns an Objective-C object, it is automatically
        converted to an :class:`ObjCInstance`. This conversion can be disabled
        by setting the ``convert_result`` keyword argument to ``False``, in
        which case the object is returned as a raw
        :class:`~rubicon.objc.runtime.objc_id` value.

        The ``_cmd`` selector argument does *not* need to be passed in manually
        --- the method's :attr:`selector` is automatically added between the
        receiver and the method arguments.
        """
        ...

class ObjCPartialMethod:
    _sentinel = ...
    def __init__(self, name_start) -> None: ...
    def __repr__(self):  # -> str:
        ...
    def __call__(self, receiver, first_arg=..., **kwargs): ...

class ObjCBoundMethod:
    """This represents an Objective-C method (an IMP) which has been bound to some id
    which will be passed as the first parameter to the method."""
    def __init__(self, method, receiver) -> None:
        """Initialize with a method and ObjCInstance or ObjCClass object."""
        ...

    def __repr__(self):  # -> str:
        ...
    def __call__(self, *args, **kwargs):
        """Call the method with the given arguments."""
        ...

def convert_method_arguments(encoding, args):  # -> list[Any]:
    """Used to convert Objective-C method arguments to Python values before passing them
    on to the Python-defined method."""
    ...

_P = ParamSpec("_P")
_TReturn = TypeVar("_TReturn")

def objc_method(callable: Callable[_P, _TReturn]) -> Callable[_P, _TReturn]:
    """Exposes the decorated method as an Objective-C instance method in a custom class
    or protocol.

    In a custom Objective-C class, decorating a method with
    [`@objc_method`][rubicon.objc.api.objc_method] makes it available to
    Objective-C: a corresponding Objective-C method is created in the new Objective-C
    class, whose implementation calls the decorated Python method. The Python method
    receives all arguments (including `self`) from the Objective-C method call, and
    its return value is passed back to Objective-C.

    In a custom Objective-C protocol, the behavior is similar, but the method
    body is ignored, since Objective-C protocol methods have no implementations.
    By convention, the method body in this case should be empty (`pass`).
    (Since the method is never called, you could put any other code there as
    well, but doing so is misleading and discouraged.)
    """

class objc_classmethod:
    """Exposes the decorated method as an Objective-C class method in a custom class or
    protocol.

    This decorator behaves exactly like :func:`@objc_method <objc_method>`, except that
    the decorated method becomes a class method, so it is exposed on the Objective-C
    class rather than its instances.
    """
    def __init__(self, py_method) -> None: ...
    def __call__(
        self, objc_cls, objc_cmd, *args
    ):  # -> int | Any | ObjCBoundMethod | None:
        ...
    def class_register(self, class_ptr, attr_name):  # -> None:
        ...
    def protocol_register(self, proto_ptr, attr_name):  # -> None:
        ...

class objc_ivar:
    """Defines an ``ivar`` in a custom Objective-C class.

    If you want to store additional data on a custom Objective-C class, it is
    recommended to use properties (:func:`objc_property`) instead of ``ivars``.
    Properties are a more modern and high-level Objective-C feature, which
    automatically deal with reference counting for objects, and creation of
    getters and setters.

    The ``ivar`` type may be any :mod:`ctypes` type.

    Unlike properties, the contents of an ``ivar`` cannot be accessed or
    modified using Python attribute syntax. Instead, the :func:`get_ivar`
    and :func:`set_ivar` functions need to be used.
    """
    def __init__(self, vartype) -> None: ...
    def class_register(self, class_ptr, attr_name):  # -> Any:
        ...
    def protocol_register(self, proto_ptr, attr_name): ...

class objc_property:
    """Defines a property in a custom Objective-C class or protocol.

    This class should be called in the body of an Objective-C subclass or
    protocol, for example:

    .. code-block:: python

        class MySubclass(NSObject):
            counter = objc_property(NSInteger)

    The property type may be any :mod:`ctypes` type, as well as any of the
    Python types accepted by :func:`~rubicon.objc.types.ctype_for_type`.

    Defining a property automatically defines a corresponding getter and setter.
    Following standard Objective-C naming conventions, for a property ``name``
    the getter is called ``name`` and the setter is called ``setName:``.

    In a custom Objective-C class, implementations for the getter and setter are
    also generated, which store the property's value in an ``ivar`` called
    ``_name``. If the property has an object type, the generated setter keeps
    the stored object retained, and releases it when it is replaced.

    In a custom Objective-C protocol, only the metadata for the property is
    generated.

    If ``weak`` is ``True``, the property will be created as a weak property.
    When assigning an object to it, the reference count of the object will not
    be increased. When the object is deallocated, the property value is set to
    None. Weak properties are only supported for Objective-C or Python object
    types.
    """
    def __init__(self, vartype=..., weak=...) -> None: ...
    def class_register(self, class_ptr, attr_name):  # -> None:
        ...
    def dealloc_callback(self, objc_self, attr_name):  # -> None:
        ...
    def protocol_register(self, proto_ptr, attr_name):  # -> None:
        ...

class objc_rawmethod:
    """Exposes the decorated method as an Objective-C instance method in a custom class,
    with fewer convenience features than :func:`objc_method`.

    This decorator behaves similarly to :func:`@objc_method <objc_method>`.
    However, unlike with :func:`objc_method`, no automatic conversions are
    performed (aside from those by :mod:`ctypes`). This means that all parameter
    and return types must be provided as :mod:`ctypes` types (no
    :func:`~rubicon.objc.types.ctype_for_type` conversion is performed), all
    arguments are passed in their raw form as received from :mod:`ctypes`, and
    the return value must be understood by :mod:`ctypes`.

    In addition, the implicit ``_cmd`` parameter is exposed to the Python
    method, which is not the case when using :func:`objc_method`. This means
    that the decorated Python method must always have an additional ``_cmd``
    parameter after ``self``; if it is missing, there will be errors at runtime
    due to mismatched argument counts. Like ``self``, ``_cmd`` never needs to be
    annotated, and any annotations on it are ignored.
    """
    def __init__(self, py_method) -> None: ...
    def __call__(self, *args, **kwargs): ...
    def class_register(self, class_ptr, attr_name):  # -> None:
        ...
    def protocol_register(self, proto_ptr, attr_name): ...

_type_for_objcclass_map = ...

def type_for_objcclass(objcclass):  # -> type[ObjCInstance]:
    """Look up the :class:`ObjCInstance` subclass used to represent instances of the
    given Objective-C class in Python.

    If the exact Objective-C class is not registered, each superclass is also
    checked, defaulting to :class:`ObjCInstance` if none of the classes in the
    superclass chain is registered. Afterwards, all searched superclasses are
    registered for the :class:`ObjCInstance` subclass that was found. (This
    speeds up future lookups, and ensures that previously computed mappings are
    not changed by unrelated registrations.)

    This method is mainly intended for internal use by Rubicon, but is exposed
    in the public API for completeness.
    """
    ...

def register_type_for_objcclass(pytype, objcclass):  # -> None:
    """Register a conversion from an Objective-C class to an :class:`ObjCInstance`
    subclass.

    After a call of this function, when Rubicon wraps an Objective-C object that
    is an instance of ``objcclass`` (or a subclass), the Python object will have
    the class ``pytype`` rather than :class:`ObjCInstance`. See
    :func:`type_for_objcclass` for a full description of the lookup process.

    .. warning::

        This function should only be called if no instances of ``objcclass`` (or
        a subclass) have been wrapped by Rubicon yet. If the function is called
        later, it will not fully take effect: the types of existing instances do
        not change, and mappings for subclasses of ``objcclass`` are not
        updated.
    """
    ...

def unregister_type_for_objcclass(objcclass):  # -> None:
    """Unregister a conversion from an Objective-C class to an :class:`ObjCInstance`
    subclass.

    .. warning::

        This function should only be called if no instances of ``objcclass`` (or
        a subclass) have been wrapped by Rubicon yet. If the function is called
        later, it will not fully take effect: the types of existing instances do
        not change, and mappings for subclasses of ``objcclass`` are not
        removed.
    """
    ...

def get_type_for_objcclass_map():  # -> dict[Any, Any]:
    """Get a copy of all currently registered :class:`ObjCInstance` subclasses as a
    mapping.

    Keys are Objective-C class addresses as :class:`int`\\s.
    """
    ...

def for_objcclass(objcclass):  # -> Callable[..., Any]:
    """Decorator for registering a conversion from an Objective-C class to an
    :class:`ObjCInstance` subclass.

    This is equivalent to calling :func:`register_type_for_objcclass` on
    the decorated class.
    """
    ...

class ObjCInstance:
    """Python wrapper for an Objective-C instance."""

    _cached_objects = ...
    _instance_lock = ...
    @property
    def objc_class(self):
        """The Objective-C object's class, as an :class:`ObjCClass`."""
        ...

    def __new__(
        cls, object_ptr, _name=..., _bases=..., _ns=..., _implicitly_owned=...
    ):  # -> type[__class_ObjCClass] | Self | None:
        """The constructor accepts an :class:`~rubicon.objc.runtime.objc_id` or anything
        that can be cast to one, such as a :class:`~ctypes.c_void_p`, or an existing
        :class:`ObjCInstance`.

        :class:`ObjCInstance` objects are cached --- this means that for every
        Objective-C object there can be at most one :class:`ObjCInstance` object
        at any time. Rubicon will automatically create new
        :class:`ObjCInstance`\\s or return existing ones as needed.

        The returned object's Python class is not always exactly
        :class:`ObjCInstance`. For example, if the passed pointer refers to a
        class or a metaclass, an instance of :class:`ObjCClass` or
        :class:`ObjCMetaClass` is returned as appropriate. Additional custom
        :class:`ObjCInstance` subclasses may be defined and registered using
        :func:`register_type_for_objcclass`. Creating an :class:`ObjCInstance`
        from a ``nil`` pointer returns ``None``.

        Rubicon retains an Objective-C object when it is wrapped in an
        :class:`ObjCInstance` and autoreleases it when the :class:`ObjCInstance` is
        garbage collected.

        The only exception to this are objects returned by methods which create an
        object (starting with "alloc", "new", "copy", or "mutableCopy"). We do not
        explicitly retain them because we already own objects created by us, but we do
        autorelease them on garbage collection of the Python wrapper.

        This ensures that the :class:`ObjCInstance` can always be used from Python
        without segfaults while preventing Rubicon from leaking memory.
        """
        ...

    def __del__(self):  # -> None:
        ...
    def __str__(self) -> str:
        """Get a human-readable representation of ``self``.

        By default, ``self.description`` converted to a Python string is
        returned. If ``self.description`` is ``nil``,
        ``self.debugDescription`` converted to a Python is returned
        instead. If that is also ``nil``, ``repr(self)`` is returned as
        a fallback.
        """
        ...

    def __repr__(self):  # -> str:
        """Get a debugging representation of ``self``, which includes the Objective-C
        object's class and ``debugDescription``."""
        ...

    def __getattr__(self, name):  # -> ObjCBoundMethod | Any:
        """Allows accessing Objective-C properties and methods using Python attribute
        syntax.

        If ``self`` has a Python attribute with the given name, its value is
        returned.

        If there is an Objective-C property with the given name, its value is
        returned using its getter method. An attribute is considered a property
        if any of the following are true:

        * A property with the name is present on the class (i.e. declared using
          ``@property`` in the source code)
        * There is both a getter and setter method for the name
        * The name has been declared as a property using
          :meth:`ObjCClass.declare_property`

        Otherwise, a method matching the given name is looked up.
        :class:`ObjCInstance` understands two syntaxes for calling Objective-C
        methods:

        * "Flat" syntax: the Objective-C method name is spelled out in the
          attribute name, with all colons replaced with underscores, and all
          arguments are passed as positional arguments. For example, the
          Objective-C method call ``[self initWithWidth:w height:h]`` translates
          to ``self.initWithWidth_height_(w, h)``.
        * "Interleaved" syntax: the Objective-C method name is split up between
          the attribute name and the keyword arguments passed to the returned
          method. For example, the Objective-C method call ``[self initWithRed:r
          green:g blue:b]`` translates to ``self.initWithRed(r, green=g,
          blue=b)``.

        The "interleaved" syntax is usually preferred, since it looks more
        similar to normal Objective-C syntax. However, the "flat" syntax is also
        fully supported. If two arguments have the same name (e.g.
        ``performSelector:withObject:withObject:``), you can use ``__`` in the
        keywords to disambiguate (e.g., ``performSelector(..., withObject__1=...,
        withObject__2=...)``. Any content after and including the ``__`` in an argument
        will be ignored.
        """
        ...

    def __setattr__(self, name, value):  # -> None:
        """Allows modifying Objective-C properties using Python syntax.

        If ``self`` has a Python attribute with the given name, it is set.
        Otherwise, the name should refer to an Objective-C property, whose
        setter method is called with ``value``.
        """
        ...

    def __delattr__(self, name):  # -> None:
        ...

class ObjCClass(ObjCInstance, type):
    """Python wrapper for an Objective-C class.

    :class:`ObjCClass` is a subclass of :class:`ObjCInstance` and supports the
    same syntaxes for calling methods and accessing properties.
    """
    @property
    def superclass(
        self,
    ):  # -> type[__class_ObjCMetaClass] | type[__class_ObjCClass] | None:
        """The superclass of this class, or ``None`` if this is a root class (such as
        :class:`NSObject`)."""
        ...

    @property
    def protocols(self):  # -> tuple[Any | type[__class_ObjCClass] | None, ...]:
        """The protocols adopted by this class."""
        ...

    auto_rename = ...
    def __new__(
        cls, name_or_ptr, bases=..., attrs=..., *, protocols=..., auto_rename=...
    ):  # -> type[__class_ObjCMetaClass] | type[__class_ObjCClass] | None:
        """The constructor accepts either the name of an Objective-C class to look up
        (as :class:`str` or :class:`bytes`), or a pointer to an existing class object
        (in any form accepted by :class:`ObjCInstance`).

        If given a pointer, it must refer to an Objective-C class; pointers to
        other objects are not accepted. (Use :class:`ObjCInstance` to wrap a
        pointer that might also refer to other kinds of objects.) If the pointer
        refers to a metaclass, an instance of :class:`ObjCMetaClass` is returned
        instead. Creating an :class:`ObjCClass` from a ``Nil`` pointer returns
        ``None``.

        :class:`ObjCClass` can also be called like :class:`type`, with three
        arguments (name, bases list, namespace mapping). This form is called
        implicitly by Python's ``class`` syntax, and is used to create a new
        Objective-C class from Python (see :ref:`custom-classes-and-protocols`).
        The bases list must contain exactly one :class:`ObjCClass` to be
        extended by the new class. An optional ``protocols`` keyword argument is
        also accepted, which must be a sequence of :class:`ObjCProtocol`\\s for
        the new class to adopt.

        If the name of the class has already registered with the Objective C
        runtime, the ``auto_rename`` option can be used to ensure that the
        Objective C name for the new class will be unique. A numeric suffix will
        be appended to the Objective C name to ensure uniqueness (for example,
        ``MyClass`` will be renamed to ``MyClass_2``, ``MyClass_3`` etc until a
        unique name is found). By default, classes will *not* be renamed, unless
        :attr:`ObjCClass.auto_rename` is set at the class level.
        """
        ...

    def __init__(self, *args, **kwargs) -> None: ...
    def declare_property(self, name):  # -> None:
        """Declare the instance method ``name`` to be a property getter.

        This causes the attribute named ``name`` on instances of this class to be
        treated as a property rather than a method --- accessing it returns the
        property's value, without requiring an explicit method call. See
        :class:`ObjCInstance.__getattr__` for a full description of how attribute access
        behaves for properties.

        Most properties do not need to be declared explicitly using this method, as they
        are detected automatically by :class:`ObjCInstance.__getattr__`. This method
        only needs to be used for properties that are read-only and don't have a
        ``@property`` declaration in the source code, because Rubicon cannot tell such
        properties apart from normal zero-argument methods.

        .. note::

            In the standard Apple SDKs, some properties are introduced as regular
            methods in one system version, and then declared as properties in a later
            system version. For example, the ``description`` method/property of
            :class:`NSObject` was declared as a regular method `up to OS X 10.9
            <https://github.com/phracker/MacOSX-SDKs/blob/9fc3ed0ad0345950ac25c28695b0427846eea966/MacOSX10.9.sdk/usr/include/objc/NSObject.h#L40>`__,
            but changed to a property `as of OS X 10.10
            <https://github.com/phracker/MacOSX-SDKs/blob/9fc3ed0ad0345950ac25c28695b0427846eea966/MacOSX10.10.sdk/usr/include/objc/NSObject.h#L43>`__.

            Such properties cause compatibility issues when accessed from Rubicon:
            ``obj.description()`` works on 10.9 but is a :class:`TypeError` on 10.10,
            whereas ``obj.description`` works on 10.10 but returns a method object on
            10.9. To solve this issue, the property can be declared explicitly using
            ``NSObject.declare_property('description')``, so that it can always be
            accessed using ``obj.description``.
        """
        ...

    def declare_class_property(self, name):  # -> None:
        """Declare the class method ``name`` to be a property getter.

        This is equivalent to
        ``self.objc_class.declare_property(name)``.
        """
        ...

    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __del__(self) -> None: ...
    def __instancecheck__(self, instance):  # -> bool:
        """Check whether the given object is an instance of this class.

        If the given object is not an Objective-C object, ``False`` is returned.

        This method allows using :class:`ObjCClass`\\es as the second argument
        of :func:`isinstance`: ``isinstance(obj, NSString)`` is equivalent to
        ``obj.isKindOfClass(NSString)``.
        """
        ...

    def __subclasscheck__(self, subclass):  # -> bool:
        """Check whether the given class is a subclass of this class.

        If the given object is not an Objective-C class, :class:`TypeError` is
        raised.

        This method allows using :class:`ObjCClass`\\es as the second argument
        of :func:`issubclass`: ``issubclass(cls, NSValue)`` is equivalent to
        ``obj.isSubclassOfClass(NSValue)``.
        """
        ...

class ObjCMetaClass(ObjCClass):
    """Python wrapper for an Objective-C metaclass.

    :class:`ObjCMetaClass` is a subclass of :class:`ObjCClass` and supports
    almost exactly the same operations and methods. However, there is usually no
    need to look up a metaclass manually. The main reason why
    :class:`ObjCMetaClass` is a separate class is to differentiate it from
    :class:`ObjCClass` in the :func:`repr`. (Otherwise there would be no way to
    tell classes and metaclasses apart, since metaclasses are also classes, and
    have exactly the same name as their corresponding class.)
    """
    def __new__(
        cls, name_or_ptr
    ):  # -> type[__class_ObjCMetaClass] | type[__class_ObjCClass] | None:
        """The constructor accepts either the name of an Objective-C metaclass to look
        up (as :class:`str` or :class:`bytes`), or a pointer to an existing metaclass
        object (in any form accepted by :class:`ObjCInstance`).

        If given a pointer, it must refer to an Objective-C metaclass; pointers
        to other objects are not accepted. (Use :class:`ObjCInstance` to wrap a
        pointer that might also refer to other kinds of objects.) Creating an
        :class:`ObjCMetaClass` from a ``Nil`` pointer returns ``None``.
        """
        ...

class _NSObjectMeta(type):
    def __new__(cls, protocols: list[ObjCProtocol] = []) -> Any: ...

class NSObject(typing.Protocol, metaclass=_NSObjectMeta):
    def __init__(self, id: ctypes.c_void_p) -> None: ...
    @classmethod
    def alloc(cls) -> Self: ...
    @classmethod
    def allocWithZone(cls, zone: None, /) -> Self: ...
    def init(self) -> Self: ...
    @property
    def copy(self) -> objc_id: ...
    @classmethod
    def copyWithZone(cls, zone: None, /) -> objc_id: ...
    @property
    def mutableCopy(self) -> objc_id: ...
    @classmethod
    def mutableCopyWithZone(cls, zone: None, /) -> objc_id: ...
    def dealloc(self) -> None: ...
    @classmethod
    def new(cls) -> Self: ...
    @classmethod
    def instancesRespondToSelector(cls, selector: bytes, /) -> bool: ...
    @classmethod
    def conformsToProtocol(cls, protocol: ObjCProtocol, /) -> bool: ...
    def methodForSelector(self, selector: bytes, /) -> ctypes._CFunctionType: ...
    @property
    def ptr(self) -> ctypes._Pointer[Self]: ...

class NSNumber(NSObject): ...
class NSDecimalNumber(NSObject): ...
class NSString(NSObject): ...
class NSData(NSObject): ...

_T = TypeVar("_T")

class NSArray(NSObject, Sequence[_T]):
    pass

NSMutableArray = ...

_TKey = TypeVar("_TKey")
_TValue = TypeVar("_TValue")

class NSDictionary(NSObject, Mapping[_TKey, _TValue]):
    def allKeys(self) -> NSArray[_TKey]: ...
    def allValues(self) -> NSArray[_TValue]: ...
    def objectForKey_(self, key: _TKey) -> _TValue: ...
    def __getitem__(self, key: _TKey) -> _TValue: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_TKey]: ...

NSMutableDictionary = ...
Protocol = ...

@overload
def py_from_ns(nsobj: NSString) -> str: ...
@overload
def py_from_ns(nsobj: NSData) -> bytes: ...

# @overload
# def py_from_ns(nsobj: NSDecimalNumber) -> decimal.Decimal: ...
@overload
def py_from_ns(nsobj: NSDictionary[_TKey, _TValue]) -> dict[_TKey, _TValue]: ...
@overload
def py_from_ns(nsobj: NSArray[_T]) -> list[_T]: ...

# @overload
# def py_from_ns(nsobj: NSNumber) -> bool | int | float: ...
def py_from_ns(
    nsobj,
):  # -> Decimal | ObjCBoundMethod | Any | str | bytes | dict[Any | Decimal | ObjCBoundMethod | str | bytes | dict[Any, Any | Decimal | ObjCBoundMethod | str | bytes | dict[Any, Any] | list[Any] | ObjCInstance | type[__class_ObjCClass] | None] | list[Any] | ObjCInstance | type[__class_ObjCClass] | None, Any | Decimal | ObjCBoundMethod | str | bytes | dict[Any | Decimal | ObjCBoundMethod | str | bytes | dict[Any, Any] | list[Any] | ObjCInstance | type[__class_ObjCClass] | None, Any] | list[Any] | ObjCInstance | type[__class_ObjCClass] | None] | list[Any] | ObjCInstance | type[__class_ObjCClass] | None:
    """Convert a Foundation object into an equivalent Python object if possible.

    Currently supported types:

    * :class:`~rubicon.objc.runtime.objc_id`: Wrapped in an
         :class:`ObjCInstance` and converted as below
    * :class:`NSString`: Converted to :class:`str`
    * :class:`NSData`: Converted to :class:`bytes`
    * :class:`NSDecimalNumber`: Converted to :class:`decimal.Decimal`
    * :class:`NSDictionary`: Converted to :class:`dict`, with all keys and
         values converted recursively
    * :class:`NSArray`: Converted to :class:`list`, with all elements converted
         recursively
    * :class:`NSNumber`: Converted to a :class:`bool`, :class:`int` or
         :class:`float` based on the type of its contents

    Other objects are returned unmodified as an :class:`ObjCInstance`.
    """
    ...

def ns_from_py(pyobj):  # -> Any | ObjCInstance | type[__class_ObjCClass] | None:
    """Convert a Python object into an equivalent Foundation object. The returned object
    is autoreleased.

    This function is also available under the name :func:`at`, because its
    functionality is very similar to that of the Objective-C ``@`` operator and
    literals.

    Currently supported types:

    * ``None``, :class:`ObjCInstance`: Returned as-is
    * :class:`enum.Enum`: Replaced by their :attr:`~enum.Enum.value` and
         converted as below
    * :class:`str`: Converted to :class:`NSString`
    * :class:`bytes`: Converted to :class:`NSData`
    * :class:`decimal.Decimal`: Converted to :class:`NSDecimalNumber`
    * :class:`dict`: Converted to :class:`NSDictionary`, with all keys and
         values converted recursively
    * :class:`list`: Converted to :class:`NSArray`, with all elements converted
         recursively
    * :class:`bool`, :class:`int`, :class:`float`: Converted to
         :class:`NSNumber`

    Other types cause a :class:`TypeError`.
    """
    ...

at = ...

@for_objcclass(Protocol)
class ObjCProtocol(ObjCInstance):
    """Python wrapper for an Objective-C protocol."""
    @property
    def name(self):  # -> Any:
        """The name of this protocol, as a :class:`str`."""
        ...

    @property
    def protocols(self):  # -> tuple[Any | type[__class_ObjCClass] | None, ...]:
        """The protocols that this protocol extends."""
        ...

    auto_rename = ...
    def __new__(
        cls, name_or_ptr, bases=..., ns=..., auto_rename=...
    ):  # -> type[__class_ObjCClass] | None:
        """The constructor accepts either the name of an Objective-C protocol to look up
        (as :class:`str` or :class:`bytes`), or a pointer to an existing protocol object
        (in any form accepted by :class:`ObjCInstance`).

        If given a pointer, it must refer to an Objective-C protocol; pointers
        to other objects are not accepted. (Use :class:`ObjCInstance` to wrap a
        pointer that might also refer to other kinds of objects.) Creating an
        :class:`ObjCProtocol` from a ``nil`` pointer returns ``None``.

        :class:`ObjCProtocol` can also be called like :class:`type`, with three
        arguments (name, bases list, namespace mapping). This form is called
        implicitly by Python's ``class`` syntax, and is used to create a new
        Objective-C protocol from Python (see
        :ref:`custom-classes-and-protocols`). The bases list can contain any
        number of :class:`ObjCProtocol` objects to be extended by the new
        protocol.

        If the name of the protocol has already registered with the Objective C
        runtime, the ``auto_rename`` option can be used to ensure that the
        Objective C name for the new protocol will be unique. A numeric suffix
        will be appended to the Objective C name to ensure uniqueness (for
        example, ``MyProtocol`` will be renamed to ``MyProtocol_2``,
        ``MyProtocol_3`` etc until a unique name is found). By default,
        protocols will *not* be renamed, unless
        :attr:`ObjCProtocol.auto_rename` is set at the class level.
        """
        ...

    def __repr__(self):  # -> str:
        ...
    def __instancecheck__(self, instance):  # -> bool:
        """Check whether the given object conforms to this protocol.

        If the given object is not an Objective-C object, ``False`` is returned.

        This method allows using :class:`ObjCProtocol`\\s as the second argument
        of :func:`isinstance`: ``isinstance(obj, NSCopying)`` is equivalent to
        ``obj.conformsToProtocol(NSCopying)``.
        """
        ...

    def __subclasscheck__(self, subclass):  # -> bool:
        """Check whether the given class or protocol conforms to this protocol.

        If the given object is not an Objective-C class or protocol,
        :class:`TypeError` is raised.

        This method allows using :class:`ObjCProtocol`\\s as the second argument
        of :func:`issubclass`: ``issubclass(cls, NSCopying)`` is equivalent to
        ``cls.conformsToProtocol(NSCopying)``, and ``issubclass(proto,
        NSCopying)`` is equivalent to ``protocol_conformsToProtocol(proto,
        NSCopying))``.
        """
        ...

NSObjectProtocol = ...
WrappedPyObject = ...

def objc_const(dll: ctypes.CDLL, name: str) -> ObjCInstance:
    """Create an :class:`ObjCInstance` from a global pointer variable in a
    :class:`~ctypes.CDLL`.

    This function is most commonly used to access constant object pointers defined by a
    library/framework, such as
    `NSCocoaErrorDomain <https://developer.apple.com/documentation/foundation/nscocoaerrordomain?language=objc>`__.
    """
    ...

_cfunc_type_block_invoke = ...
_cfunc_type_block_dispose = ...
_cfunc_type_block_copy = ...

class ObjCBlockStruct(Structure):
    _fields_ = ...

class BlockDescriptor(Structure):
    _fields_ = ...

class BlockLiteral(Structure):
    _fields_ = ...

def create_block_descriptor_struct(
    has_helpers, has_signature
):  # -> type[ObjCBlockDescriptor]:
    ...
def cast_block_descriptor(block):  # -> _Pointer[ObjCBlockDescriptor]:
    ...

AUTO = ...

class BlockConsts:
    HAS_COPY_DISPOSE = ...
    HAS_CTOR = ...
    IS_GLOBAL = ...
    HAS_STRET = ...
    HAS_SIGNATURE = ...

class ObjCBlock:
    """Python wrapper for an Objective-C block object.

    This class is used to manually wrap an Objective-C block so that it
    can be called from Python. Usually Rubicon will do this
    automatically, if the block object was returned from an Objective-C
    method whose return type is declared to be a block type. If this
    automatic detection fails, for example if the method's return type
    is generic ``id``, Rubicon has no way to tell that the object in
    question is a block rather than a regular Objective-C object. In
    that case, the object needs to be manually wrapped using
    :class:`ObjCBlock`.
    """
    def __init__(self, pointer, restype=..., *argtypes) -> None:
        """The constructor takes a block object, which can be either an
        :class:`ObjCInstance`, or a raw :class:`~rubicon.objc.runtime.objc_id` pointer.

        .. note::

            :class:`~rubicon.objc.runtime.objc_block` is also accepted,
            because it is a subclass of :class:`~rubicon.objc.runtime.objc_id`).
            Normally you do not need to make use of this, because in most cases
            Rubicon will automatically convert
            :class:`~rubicon.objc.runtime.objc_block`\\s to a callable object.

        In most cases, Rubicon can automatically determine the block's return
        type and parameter types. If a block object doesn't have return/parameter
        type information at runtime, Rubicon will raise an error when attempting
        to convert it. In that case, you need to explicitly pass the correct
        return type and parameter types to :class:`ObjCBlock` using the
        ``restype`` and ``argtypes`` parameters.
        """
        ...

    def __repr__(self):  # -> Any | str:
        ...
    def __call__(self, *args):  # -> Any:
        """Invoke the block object with the given arguments.

        The arguments and return value are converted from/to Python
        objects according to the default ``ctypes`` rules, based on the
        block's return and parameter types.
        """
        ...

class ObjCBlockInstance(ObjCInstance):
    def __call__(self, *args):  # -> Any:
        ...

_NSConcreteStackBlock = ...
NOTHING = ...

class Block:
    """A wrapper that exposes a Python callable object to Objective-C as a block.

    .. note::

        :class:`Block` instances are currently *not* callable from Python,
        unlike :class:`ObjCBlock`.
    """

    _keep_alive_blocks_ = ...
    def __init__(self, func, restype=..., *argtypes) -> None:
        """The constructor accepts any Python callable object.

        If the callable has parameter and return type annotations, they are used
        as the block's parameter and return types. This allows using
        :class:`Block` as a decorator:

        .. code-block:: python

            @Block
            def the_block(arg: NSInteger) -> NSUInteger:
                return abs(arg)

        For callables without type annotations, the parameter and return types
        need to be passed to the :class:`Block` constructor in the ``restype``
        and ``argtypes`` arguments:

        .. code-block:: python

            the_block = Block(abs, NSUInteger, NSInteger)
        """
        ...

    def wrapper(self, block, *args):  # -> object:
        ...
    def dispose_helper(self, dst):  # -> None:
        ...
    def copy_helper(self, dst, src):  # -> None:
        ...
