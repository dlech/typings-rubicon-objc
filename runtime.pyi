"""
This type stub file was initially generated by pyright.
"""

# pyright: reportPrivateUsage=false

import ctypes
from collections.abc import Callable, Generator, Iterable, Sequence
from contextlib import contextmanager
from ctypes import CDLL, Structure, c_void_p
from typing import Any

from rubicon.objc.api import ObjCClass, ObjCInstance
from typing_extensions import Self

from .types import __arm__, __i386__, __x86_64__, with_encoding, with_preferred_encoding

__all__ = [
    "Class",
    "Foundation",
    "IMP",
    "Ivar",
    "Method",
    "SEL",
    "add_ivar",
    "add_method",
    "autoreleasepool",
    "get_class",
    "get_ivar",
    "libc",
    "libobjc",
    "load_library",
    "objc_block",
    "objc_id",
    "objc_method_description",
    "objc_property_t",
    "objc_super",
    "object_isClass",
    "send_message",
    "send_super",
    "set_ivar",
    "should_use_fpret",
    "should_use_stret",
]
_lib_path = ...
_framework_path = ...

def load_library(name: str) -> CDLL:
    """Load and return the C library with the given name.

    If the library could not be found, a :class:`ValueError` is raised.

    Internally, this function uses :func:`ctypes.util.find_library` to search
    for the library in the system-standard locations. If the library cannot be
    found this way, it is attempted to load the library from certain hard-coded
    locations, as a fallback for systems where ``find_library`` does not work
    (such as iOS).
    """
    ...

libc: CDLL
libobjc: CDLL
Foundation: CDLL

@with_encoding(b"@")
class objc_id(c_void_p):
    """The `id <https://developer.apple.com/documentation/objectivec/id?language=objc>`__
    type from ``<objc/objc.h>``.
    """

    ...

@with_encoding(b"@?")
class objc_block(objc_id):
    """The low-level type of block pointers.

    This type tells Rubicon's internals that the object in question is a block
    and not just a regular Objective-C object, which affects method argument and
    return value conversions. For more details, see :ref:`objc_blocks`.

    .. note::

        This type does not correspond to an actual C type or Objective-C class.
        Although the internal structure of block objects is documented, as well
        as the fact that they are Objective-C objects, they do not have a
        documented type or class name and are not fully defined in any header
        file.

        Aside from the special conversion behavior, this type is equivalent to
        :class:`objc_id`.
    """

    ...

@with_preferred_encoding(b":")
class SEL(c_void_p):
    """The `SEL <https://developer.apple.com/documentation/objectivec/sel?language=objc>`__
    type from ``<objc/objc.h>``.
    """
    @property
    def name(self) -> bytes:
        """The selector's name as :class:`bytes`."""
        ...

    def __new__(cls, init: bytes | str | None = None) -> Self:
        """The constructor can be called with a :class:`bytes` or :class:`str` object to
        obtain a selector with that value.

        (The normal arguments supported by :class:`~ctypes.c_void_p` are
        still accepted.)
        """
        ...

    def __init__(self, init: bytes | str | None = None) -> None: ...
    def __repr__(self) -> str: ...

@with_preferred_encoding(b"#")
class Class(objc_id):
    """The `Class <https://developer.apple.com/documentation/objectivec/class?language=objc>`__
    type from ``<objc/objc.h>``.
    """

    ...

class IMP(c_void_p):
    """The `IMP <https://developer.apple.com/documentation/objectivec/imp?language=objc>`__
    type from ``<objc/objc.h>``.

    An :class:`IMP` cannot be called directly --- it must be cast to the
    correct :func:`~ctypes.CFUNCTYPE` first, to provide the necessary
    information about its signature.
    """

    ...

class Method(c_void_p):
    """The `Method <https://developer.apple.com/documentation/objectivec/method?language=objc>`__
    type from ``<objc/runtime.h>``.
    """

    ...

class Ivar(c_void_p):
    """The `Ivar <https://developer.apple.com/documentation/objectivec/ivar?language=objc>`__
    type from ``<objc/runtime.h>``.
    """

    ...

class objc_property_t(c_void_p):
    """The `objc_property_t <https://developer.apple.com/documentation/objectivec/objc_property_t?language=objc>`__
    type from ``<objc/runtime.h>``.
    """

    ...

class objc_property_attribute_t(Structure):
    """
    The `objc_property_attribute_t <https://developer.apple.com/documentation/objectivec/objc_property_attribute_t?language=objc>`__
    structure from ``<objc/runtime.h>``.
    """

    _fields_ = ...

if __i386__ or __x86_64__ or __arm__: ...
if __i386__ or __x86_64__: ...
object_isClass = ...

class objc_method_description(Structure):
    """The `objc_method_description <https://developer.apple.com/documentation/objectivec/objc_method_description?language=objc>`__
    structure from ``<objc/runtime.h>``.
    """

    _fields_ = ...

def ensure_bytes(x: bytes | str) -> bytes:
    """Convert the given string to :class:`bytes` if necessary.

    If the argument is already :class:`bytes`, it is returned unchanged;
    if it is :class:`str`, it is encoded as UTF-8.
    """
    ...

def get_class(name: bytes | str) -> Class | None:
    """Get the Objective-C class with the given name as a :class:`Class` object.

    If no class with the given name is loaded, ``None`` is returned, and
    the Objective-C runtime will log a warning message.
    """
    ...

def should_use_stret(restype: Any) -> bool:
    """Return whether a method returning the given type must be called using
    ``objc_msgSend_stret`` on the current system."""
    ...

def should_use_fpret(restype: Any) -> bool:
    """Return whether a method returning the given type must be called using
    ``objc_msgSend_fpret`` on the current system."""
    ...

_msg_send_cache = ...

def send_message(
    receiver: ObjCInstance | objc_id,
    selector: str | bytes | SEL,
    *args: Any,
    restype: Any = ...,
    argtypes: Sequence[Any] | None = None,
    varargs: Sequence[Any] | None = None,
) -> Any:
    """Call a method on the receiver with the given selector and arguments.

    This is the equivalent of an Objective-C method call like ``[receiver sel:args]``.

    .. note::

        Some Objective-C methods take variadic arguments (``varargs``), for example
        `+[NSString stringWithFormat:] <https://developer.apple.com/documentation/foundation/nsstring/stringwithformat:?language=objc>`_.
        When using :func:`send_message`, variadic arguments are treated
        differently from regular arguments: they are not passed as normal
        function arguments in ``*args``, but as a list in a separate ``varargs``
        keyword argument.

        This explicit separation of regular and variadic arguments protects
        against accidentally passing too many arguments into a method. By
        default these extra arguments would be considered ``varargs`` and passed on
        to the method, even if the method in question doesn't take ``varargs``.
        Because of how the Objective-C runtime and most C calling conventions
        work, this error would otherwise be silently ignored.

        The types of ``varargs`` are not included in the ``argtypes`` list. Instead,
        the values are automatically converted to C types using the default
        :mod:`ctypes` argument conversion rules. To ensure that all ``varargs`` are
        converted to the expected C types, it is recommended to manually convert
        all ``varargs`` to :mod:`ctypes` types instead of relying on automatic
        conversions. For example:

        .. code-block:: python

            send_message(
                NSString,
                "stringWithFormat:",
                at("%i %s %@"),
                restype=objc_id,
                argtypes=[objc_id],
                varargs=[c_int(123), cast(b"C string", c_char_p), at("ObjC string")],
            )

    :param receiver: The object on which to call the method, as an
        :class:`~rubicon.objc.api.ObjCInstance` or :class:`.objc_id`.
    :param selector: The name of the method as a :class:`str`, :class:`bytes`,
        or :class:`SEL`.
    :param args: The method arguments.
    :param restype: The return type of the method.
    :param argtypes: The argument types of the method, as a :class:`list`.
        Defaults to ``[]``.
    :param varargs: Variadic arguments for the method, as a :class:`list`.
        Defaults to ``[]``. These arguments are converted according to the
        default :mod:`ctypes` conversion rules.
    """
    ...

class objc_super(Structure):
    """The `objc_super <https://developer.apple.com/documentation/objectivec/objc_super?language=objc>`__
    structure from ``<objc/message.h>``.
    """

    _fields_ = ...

def send_super(
    cls: ObjCClass | Class,
    receiver: ObjCInstance | objc_id,
    selector: str | bytes | SEL,
    *args: Any,
    restype: Any = ...,
    argtypes: Sequence[Any] | None = None,
    varargs: Sequence[Any] | None = None,
    _allow_dealloc: bool = False,
) -> Any:
    """In the context of the given class, call a superclass method on the receiver with
    the given selector and arguments.

    This is the equivalent of an Objective-C method call like
    ``[super sel:args]`` in the class ``cls``.

    In practice, the first parameter should always be the special variable
    ``__class__``, and the second parameter should be ``self``. A typical
    :func:`send_super` call would be ``send_super(__class__, self, 'init')``
    for example.

    The special variable ``__class__`` is defined by Python and stands for the
    class object that is being created by the current ``class`` block. The
    exact reasons why ``__class__`` must be passed manually are somewhat
    technical, and are not directly relevant to users of :func:`send_super`.
    For a full explanation, see issue `beeware/rubicon-objc#107
    <https://github.com/beeware/rubicon-objc/issues/107>`__ and PR
    `beeware/rubicon-objc#108 <https://github.com/beeware/rubicon-objc/pull/108>`__.

    Although it is possible to pass other values than ``__class__`` and
    ``self`` for the first two parameters, this is strongly discouraged. Doing
    so is not supported by the Objective-C language, and relies on
    implementation details of the superclasses.

    :param cls: The class in whose context the ``super`` call is happening, as
        an :class:`~rubicon.objc.api.ObjCClass` or :class:`Class`.
    :param receiver: The object on which to call the method, as an
        :class:`~rubicon.objc.api.ObjCInstance`, :class:`.objc_id`, or
        :class:`~ctypes.c_void_p`.
    :param selector: The name of the method as a :class:`str`, :class:`bytes`,
        or :class:`SEL`.
    :param args: The method arguments.
    :param restype: The return type of the method.
    :param argtypes: The argument types of the method, as a :class:`list`.
        Defaults to ``[]``.
    :param varargs: Variadic arguments for the method, as a :class:`list`.
        Defaults to ``[]``. These arguments are converted according to the
        default :mod:`ctypes` conversion rules.
    """
    ...

_keep_alive_imps = ...

def add_method(
    cls: ObjCClass | Class,
    selector: str | bytes | SEL,
    method: Callable[..., Any] | ctypes._CFunctionType,
    encoding: Iterable[type[Any]],
    replace: bool = False,
) -> ctypes._CFunctionType:
    """Add a new instance method to the given class.

    To add a class method, add an instance method to the metaclass.

    :param cls: The Objective-C class to which to add the method, as an
        :class:`~rubicon.objc.api.ObjCClass` or :class:`Class`.
    :param selector: The name for the new method, as a :class:`str`,
        :class:`bytes`, or :class:`SEL`.
    :param method: The method implementation, as a Python callable or a C
        function address.
    :param encoding: The method's signature (return type and argument types) as
        a :class:`list`. The types of the implicit ``self`` and ``_cmd``
        parameters must be included in the signature.
    :param replace: If the class already implements a method with the given
        name, replaces the current implementation if ``True``. Raises a
        :class:`ValueError` error otherwise.
    :return: The ctypes C function pointer object that was created for the
        method's implementation. This return value can be ignored. (In version
        0.4.0 and older, callers were required to manually keep a reference to
        this function pointer object to ensure that it isn't garbage-collected.
        Rubicon now does this automatically.)
    """
    ...

def add_ivar(
    cls: Class,
    name: str | bytes,
    vartype: ctypes._CData
    | ctypes._CDataType
    | type[ctypes._CData | ctypes._CDataType],
) -> bool:
    """Add a new instance variable of type ``vartype`` to ``cls``."""
    ...

def get_ivar(
    obj: ObjCInstance, varname: str | bytes, weak: bool = False
) -> ctypes._CData:
    """Get the value of obj's ``ivar`` named ``varname``.

    The returned object is a :mod:`ctypes` data object.

    For non-object types (everything except :class:`.objc_id` and subclasses),
    the returned data object is backed by the ``ivar``'s actual memory. This means
    that the data object is only usable as long as the "owner" object is alive,
    and writes to it will directly change the ``ivar``'s value.

    For object types, the returned data object is independent of the ``ivar``'s
    memory. This is because object ``ivars`` may be weak, and thus cannot always
    be accessed directly by their address.
    """
    ...

def set_ivar(
    obj: ObjCInstance, varname: str | bytes, value: ctypes._CData, weak: bool = False
) -> None:
    """Set obj's ``ivar`` ``varname`` to value. If ``weak`` is ``True``, only a weak
    reference to the value is stored.

    value must be a :mod:`ctypes` data object whose type matches that of
    the ``ivar``.
    """
    ...

@contextmanager
def autoreleasepool() -> Generator[None, Any, None]:
    """A context manager that has the same effect as a @autoreleasepool block in
    Objective-C.

    Any objects that are autoreleased within the context will receive a release message
    when exiting the context. When running an event loop, AppKit will create an
    autorelease pool at the beginning of each cycle of the event loop and drain it at
    the end. You therefore do not need to use @autoreleasepool blocks when running an
    event loop. However, they may be still be useful when your code temporarily
    allocates large amounts of memory which you want to explicitly free before the end
    of a cycle.
    """
    ...
